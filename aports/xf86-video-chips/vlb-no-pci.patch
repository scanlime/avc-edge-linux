diff --git a/src/ct_driver.c b/src/ct_driver.c
index b4b8422..053c802 100644
--- a/src/ct_driver.c
+++ b/src/ct_driver.c
@@ -134,12 +134,9 @@
 /* Mandatory functions */
 static const OptionInfoRec *	CHIPSAvailableOptions(int chipid, int busid);
 static void     CHIPSIdentify(int flags);
-#ifdef XSERVER_LIBPCIACCESS
 static Bool     CHIPSPciProbe(DriverPtr drv, int entity_num,
 			      struct pci_device *dev, intptr_t match_data);
-#else
 static Bool     CHIPSProbe(DriverPtr drv, int flags);
-#endif
 static Bool     CHIPSPreInit(ScrnInfoPtr pScrn, int flags);
 static Bool     CHIPSScreenInit(SCREEN_INIT_ARGS_DECL);
 static Bool     CHIPSEnterVT(VT_FUNC_ARGS_DECL);
@@ -473,8 +470,6 @@ static DisplayModeRec ChipsNTSCMode = {
 #define CHIPS_PATCHLEVEL PACKAGE_VERSION_PATCHLEVEL
 
 
-#ifdef XSERVER_LIBPCIACCESS
-
 #ifndef _XF86_PCIINFO_H
 #define PCI_VENDOR_CHIPSTECH		0x102C
 /* Chips & Tech */
@@ -502,7 +497,6 @@ static const struct pci_id_match chips_device_match[] = {
   CHIPS_DEVICE_MATCH(PCI_CHIP_69030, CHIPS_CT69030),
   { 0, 0, 0 },
 };
-#endif
 
 /*
  * This contains the functions needed by the server after loading the driver
@@ -516,20 +510,11 @@ _X_EXPORT DriverRec CHIPS = {
 	CHIPS_VERSION,
 	CHIPS_DRIVER_NAME,
 	CHIPSIdentify,
-#ifdef XSERVER_LIBPCIACCESS
-	NULL,
-#else
 	CHIPSProbe,
-#endif
 	CHIPSAvailableOptions,
 	NULL,
 	0,
 	NULL,
-
-#ifdef XSERVER_LIBPCIACCESS
-	chips_device_match,
-	CHIPSPciProbe,
-#endif
 };
 
 static SymTabRec CHIPSChipsets[] = {
@@ -809,7 +794,6 @@ CHIPSAvailableOptions(int chipid, int busid)
 }
 
 /* Mandatory */
-#ifdef XSERVER_LIBPCIACCESS
 Bool
 CHIPSPciProbe(DriverPtr drv, int entity_num, struct pci_device * dev,
 	    intptr_t match_data)
@@ -873,7 +857,8 @@ CHIPSPciProbe(DriverPtr drv, int entity_num, struct pci_device * dev,
 
     return (pScrn != NULL);
 }
-#else
+
+/* Used for ISA only */
 static Bool
 CHIPSProbe(DriverPtr drv, int flags)
 {
@@ -891,74 +876,6 @@ CHIPSProbe(DriverPtr drv, int flags)
 					  &devSections)) <= 0) {
 	return FALSE;
     }
-    /* PCI BUS */
-    if (xf86GetPciVideoInfo() ) {
-	numUsed = xf86MatchPciInstances(CHIPS_NAME, PCI_VENDOR_CHIPSTECH,
-					CHIPSChipsets, CHIPSPCIchipsets, 
-					devSections,numDevSections, drv,
-					&usedChips);
-	if (numUsed > 0) {
-	    if (flags & PROBE_DETECT)
-		foundScreen = TRUE;
-	    else for (i = 0; i < numUsed; i++) {
-		EntityInfoPtr pEnt;
-		/* Allocate a ScrnInfoRec  */
-		ScrnInfoPtr pScrn = NULL;
-		if ((pScrn = xf86ConfigPciEntity(pScrn,0,usedChips[i],
-						       CHIPSPCIchipsets,NULL,
-						       NULL,NULL,NULL,NULL))){
-		    pScrn->driverVersion = CHIPS_VERSION;
-		    pScrn->driverName    = CHIPS_DRIVER_NAME;
-		    pScrn->name          = CHIPS_NAME;
-		    pScrn->Probe         = CHIPSProbe;
-		    pScrn->PreInit       = CHIPSPreInit;
-		    pScrn->ScreenInit    = CHIPSScreenInit;
-		    pScrn->SwitchMode    = CHIPSSwitchMode;
-		    pScrn->AdjustFrame   = CHIPSAdjustFrame;
-		    pScrn->EnterVT       = CHIPSEnterVT;
-		    pScrn->LeaveVT       = CHIPSLeaveVT;
-		    pScrn->FreeScreen    = CHIPSFreeScreen;
-		    pScrn->ValidMode     = CHIPSValidMode;
-		    foundScreen = TRUE;
-		}
-
-		/*
-		 * For cards that can do dual head per entity, mark the entity
-		 * as sharable.
-		 */
-		pEnt = xf86GetEntityInfo(usedChips[i]);
-		if (pEnt->chipset == CHIPS_CT69030) {
-		    CHIPSEntPtr cPtrEnt = NULL;
-		    DevUnion *pPriv;
-
-		    xf86SetEntitySharable(usedChips[i]);
-		    /* Allocate an entity private if necessary */
-		    if (CHIPSEntityIndex < 0)
-			CHIPSEntityIndex = xf86AllocateEntityPrivateIndex();
-		    pPriv = xf86GetEntityPrivate(pScrn->entityList[0], 
-				CHIPSEntityIndex);
-		    if (!pPriv->ptr) {
-			pPriv->ptr = xnfcalloc(sizeof(CHIPSEntRec), 1);
-			cPtrEnt = pPriv->ptr;
-			cPtrEnt->lastInstance = -1;
-		    } else {
-			cPtrEnt = pPriv->ptr;
-		    }
-		    /*
-		     * Set the entity instance for this instance of the 
-		     * driver.  For dual head per card, instance 0 is the 
-		     * "master" instance, driving the primary head, and 
-                     * instance 1 is the "slave".
-		     */
-		    cPtrEnt->lastInstance++;
-		    xf86SetEntityInstanceForScreen(pScrn, pScrn->entityList[0],
-						   cPtrEnt->lastInstance);
-		}
-
-	    }
-	    free(usedChips);
-	}
-    }
 
 #ifdef HAVE_ISA
     /* Isa Bus */
@@ -996,9 +913,7 @@ CHIPSProbe(DriverPtr drv, int flags)
     free(devSections);
     return foundScreen;
 }
-#endif
 
-#ifdef HAVE_ISA
 static int
 chipsFindIsaDevice(GDevPtr dev)
 {
@@ -1082,7 +997,6 @@ chipsFindIsaDevice(GDevPtr dev)
     }
     return found;
 }
-#endif
 
 /* Mandatory */
 Bool
@@ -1118,9 +1032,6 @@ CHIPSPreInit(ScrnInfoPtr pScrn, int flags)
     /* This is the general case */
     for (i = 0; i<pScrn->numEntities; i++) {
 	cPtr->pEnt = xf86GetEntityInfo(pScrn->entityList[i]);
-#ifndef XSERVER_LIBPCIACCESS
-	if (cPtr->pEnt->resources) return FALSE;
-#endif
 	/* If we are using libpciaccess this is already set in CHIPSPciProbe.
 	 * If we are using something else we need to set it here.
 	 */
@@ -1137,11 +1048,6 @@ CHIPSPreInit(ScrnInfoPtr pScrn, int flags)
 	if (cPtr->pEnt->location.type == BUS_PCI) {
 	    pciPtr = xf86GetPciInfoForEntity(cPtr->pEnt->index);
 	    cPtr->PciInfo = pciPtr;
-#ifndef XSERVER_LIBPCIACCESS
-	    cPtr->PciTag = pciTag(cPtr->PciInfo->bus, 
-				  cPtr->PciInfo->device,
-				  cPtr->PciInfo->func);
-#endif
 	}
     }
     /* INT10 */
@@ -1376,14 +1282,6 @@ CHIPSPreInit(ScrnInfoPtr pScrn, int flags)
 	}
     }
 
-#ifndef XSERVER_LIBPCIACCESS
-    if (cPtr->Flags & ChipsLinearSupport) 
- 	xf86SetOperatingState(resVgaMem, cPtr->pEnt->index, ResDisableOpr);
-
-    if (cPtr->MMIOBaseVGA)
- 	xf86SetOperatingState(resVgaIo, cPtr->pEnt->index, ResDisableOpr);
-#endif
-
     vbeFree(cPtr->pVbe);
     cPtr->pVbe = NULL;
     return TRUE;
@@ -1408,9 +1306,6 @@ chipsPreInitHiQV(ScrnInfoPtr pScrn, int flags)
     CHIPSPanelSizePtr Size = &cPtr->PanelSize;
     CHIPSMemClockPtr MemClk = &cPtr->MemClock;
     CHIPSClockPtr SaveClk = &(cPtr->SavedReg.Clock);
-#ifndef XSERVER_LIBPCIACCESS
-    resRange linearRes[] = { {ResExcMemBlock|ResBios|ResBus,0,0},_END };
-#endif
 
     /* Set pScrn->monitor */
     pScrn->monitor = pScrn->confScreen->monitor;
@@ -1572,10 +1467,6 @@ chipsPreInitHiQV(ScrnInfoPtr pScrn, int flags)
 	        cPtr->FbAddress =  PCI_REGION_BASE(cPtr->PciInfo, 0, REGION_MEM) & 0xff800000;
 
 	    from = X_PROBED;
-#ifndef XSERVER_LIBPCIACCESS
-	    if (xf86RegisterResources(cPtr->pEnt->index,NULL,ResNone))
-		cPtr->Flags &= ~ChipsLinearSupport;
-#endif
 	} else 	{
 	    if (cPtr->pEnt->device->MemBase) {
 		cPtr->FbAddress = cPtr->pEnt->device->MemBase;
@@ -1587,14 +1478,6 @@ chipsPreInitHiQV(ScrnInfoPtr pScrn, int flags)
 				    (0x80 & (cPtr->readXR(cPtr, 0x05)))) << 16;
 		from = X_PROBED;
 	    }
-#ifndef XSERVER_LIBPCIACCESS
-	    linearRes[0].rBegin = cPtr->FbAddress;
-	    linearRes[0].rEnd = cPtr->FbAddress + 0x800000;
-	    if (xf86RegisterResources(cPtr->pEnt->index,linearRes,ResNone)) {
-		cPtr->Flags &= ~ChipsLinearSupport;
-		from = X_PROBED;
-	    }
-#endif
 	}
     }
     if (cPtr->Flags & ChipsLinearSupport) {
@@ -2424,9 +2307,6 @@ chipsPreInitWingine(ScrnInfoPtr pScrn, int flags)
     CHIPSClockPtr SaveClk = &(cPtr->SavedReg.Clock);
     Bool useLinear = FALSE;
     const char *s;
-#ifndef XSERVER_LIBPCIACCESS
-    resRange linearRes[] = { {ResExcMemBlock|ResBios|ResBus,0,0},_END };
-#endif
 
     /* Set pScrn->monitor */
     pScrn->monitor = pScrn->confScreen->monitor;
@@ -2630,14 +2510,6 @@ chipsPreInitWingine(ScrnInfoPtr pScrn, int flags)
 	    cPtr->FbAddress |= ((mask  & (cPtr->readXR(cPtr, 0x08))) << 16);
 	    from = X_PROBED;
 	}
-#ifndef XSERVER_LIBPCIACCESS
-	linearRes[0].rBegin = cPtr->FbAddress;
-	linearRes[0].rEnd = cPtr->FbAddress + 0x800000;
-	if (xf86RegisterResources(cPtr->pEnt->index,linearRes,ResNone)) {
-	    useLinear = FALSE;
-	    from = X_PROBED;
-	}
-#endif
     }
 
     if (useLinear) {
@@ -2748,25 +2620,6 @@ chipsPreInitWingine(ScrnInfoPtr pScrn, int flags)
 	    ErrorF("DR[%X] = %X\n",i,cPtr->Regs32[i]);
 #endif
 	}
-#ifndef XSERVER_LIBPCIACCESS
-	linearRes[0].type = ResExcIoSparse | ResBios | ResBus;
-	linearRes[0].rBase = cPtr->Regs32[0];
-	linearRes[0].rMask = 0x83FC;
-	if (xf86RegisterResources(cPtr->pEnt->index,linearRes,ResNone)) {
-	    if (cPtr->Flags & ChipsAccelSupport) {
-		cPtr->Flags &= ~ChipsAccelSupport;
-		xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-			   "Cannot allocate IO registers: "
-			   "Disabling acceleration\n");
-	    }
-	    if (cPtr->Accel.UseHWCursor) {
-		cPtr->Accel.UseHWCursor = FALSE;
-		xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-			   "Cannot allocate IO registers: "
-			   "Disabling HWCursor\n");
-	    }
-	}
-#endif
     }
 
     cPtr->ClockMulFactor = ((pScrn->bitsPerPixel >= 8) ? bytesPerPixel : 1);
@@ -2892,9 +2745,6 @@ chipsPreInit655xx(ScrnInfoPtr pScrn, int flags)
     CHIPSClockPtr SaveClk = &(cPtr->SavedReg.Clock);
     Bool useLinear = FALSE;
     const char *s;
-#ifndef XSERVER_LIBPCIACCESS
-    resRange linearRes[] = { {ResExcMemBlock|ResBios|ResBus,0,0},_END };
-#endif
 
     /* Set pScrn->monitor */
     pScrn->monitor = pScrn->confScreen->monitor;
@@ -3098,12 +2948,6 @@ chipsPreInit655xx(ScrnInfoPtr pScrn, int flags)
 	}
 	if (cPtr->pEnt->location.type == BUS_PCI) {
 	    cPtr->FbAddress =  PCI_REGION_BASE(cPtr->PciInfo, 0, REGION_MEM) & 0xff800000;
-#ifndef XSERVER_LIBPCIACCESS
-	    if (xf86RegisterResources(cPtr->pEnt->index,NULL,ResNone)) {
-	        useLinear = FALSE;
-		from = X_PROBED;
-	    }
-#endif
 	} else {
 	    if (cPtr->pEnt->device->MemBase) {
 		cPtr->FbAddress = cPtr->pEnt->device->MemBase;
@@ -3127,14 +2971,6 @@ chipsPreInit655xx(ScrnInfoPtr pScrn, int flags)
 		}
 		from = X_PROBED;
 	    }
-#ifndef XSERVER_LIBPCIACCESS
-	    linearRes[0].rBegin = cPtr->FbAddress;
-	    linearRes[0].rEnd = cPtr->FbAddress + 0x800000;
-	    if (xf86RegisterResources(cPtr->pEnt->index,linearRes,ResNone)) {
-		useLinear = FALSE;
-		from = X_PROBED;
-	    }
-#endif
 	}
     }
 
@@ -3434,25 +3270,6 @@ chipsPreInit655xx(ScrnInfoPtr pScrn, int flags)
 	    ErrorF("DR[%X] = %X\n",i,cPtr->Regs32[i]);
 #endif
 	}
-#ifndef XSERVER_LIBPCIACCESS
-	linearRes[0].type = ResExcIoSparse | ResBios | ResBus;
-	linearRes[0].rBase = cPtr->Regs32[0];
-	linearRes[0].rMask = 0x83FC;
-	if (xf86RegisterResources(cPtr->pEnt->index,linearRes,ResNone)) {
-	    if (cPtr->Flags & ChipsAccelSupport) {
-		cPtr->Flags &= ~ChipsAccelSupport;
-		xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-			   "Cannot allocate IO registers: "
-			   "Disabling acceleration\n");
-	    }
-	    if (cPtr->Accel.UseHWCursor) {
-		cPtr->Accel.UseHWCursor = FALSE;
-		xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-			   "Cannot allocate IO registers: "
-			   "Disabling HWCursor\n");
-	    }
-	}
-#endif
     }
 
     /* sync reset ignored on this chipset */
@@ -3849,9 +3666,6 @@ CHIPSScreenInit(SCREEN_INIT_ARGS_DECL)
     int init_picture = 0;
     VisualPtr visual;
     int allocatebase, freespace, currentaddr;
-#ifndef XSERVER_LIBPCIACCESS
-    unsigned int racflag = 0;
-#endif
     unsigned char *FBStart;
     int height, width, displayWidth;
     CHIPSEntPtr cPtrEnt = NULL;
@@ -4322,14 +4136,6 @@ CHIPSScreenInit(SCREEN_INIT_ARGS_DECL)
 		NULL, CMAP_RELOAD_ON_MODE_SWITCH | CMAP_PALETTED_TRUECOLOR))
 	return FALSE;
 
-#ifndef XSERVER_LIBPCIACCESS
-    racflag = RAC_COLORMAP;
-    if (cAcl->UseHWCursor)
-        racflag |= RAC_CURSOR;
-    racflag |= (RAC_FB | RAC_VIEWPORT);
-    /* XXX Check if I/O and Mem flags need to be the same. */
-    pScrn->racIoFlags = pScrn->racMemFlags = racflag;
-#endif
 #ifdef ENABLE_SILKEN_MOUSE
 	xf86SetSilkenMouse(pScreen);
 #endif
@@ -6903,47 +6709,11 @@ chipsMapMem(ScrnInfoPtr pScrn)
     if (cPtr->Flags & ChipsLinearSupport) {
 	if (cPtr->UseMMIO) {
 	    if (IS_HiQV(cPtr)) {
-#ifndef XSERVER_LIBPCIACCESS
-		if (cPtr->pEnt->location.type == BUS_PCI)
-		    cPtr->MMIOBase = xf86MapPciMem(pScrn->scrnIndex,
-			   VIDMEM_MMIO_32BIT,cPtr->PciTag, cPtr->IOAddress,
-			   0x20000L);
-		 else 
 		    cPtr->MMIOBase = xf86MapVidMem(pScrn->scrnIndex,
 			   VIDMEM_MMIO_32BIT, cPtr->IOAddress, 0x20000L);
-#else
-		{
-		  void** result = (void**)&cPtr->MMIOBase;
-		  int err = pci_device_map_range(cPtr->PciInfo,
-						 cPtr->IOAddress,
-						 0x20000L,
-						 PCI_DEV_MAP_FLAG_WRITABLE,
-						 result);
-		  if (err) 
-		    return FALSE;
-		}
-#endif
 	    } else {
-#ifndef XSERVER_LIBPCIACCESS
-		if (cPtr->pEnt->location.type == BUS_PCI)
-		    cPtr->MMIOBase = xf86MapPciMem(pScrn->scrnIndex,
-			  VIDMEM_MMIO_32BIT, cPtr->PciTag, cPtr->IOAddress,
-			  0x10000L);
-		else
 		    cPtr->MMIOBase = xf86MapVidMem(pScrn->scrnIndex,
 			  VIDMEM_MMIO_32BIT, cPtr->IOAddress, 0x10000L);
-#else
-		{
-		  void** result = (void**)&cPtr->MMIOBase;
-		  int err = pci_device_map_range(cPtr->PciInfo,
-						 cPtr->IOAddress,
-						 0x10000L,
-						 PCI_DEV_MAP_FLAG_WRITABLE,
-						 result);
-		  if (err) 
-		    return FALSE;
-		}
-#endif
 	    }
 
 	    if (cPtr->MMIOBase == NULL)
@@ -6966,40 +6736,14 @@ chipsMapMem(ScrnInfoPtr pScrn)
 	    }
 	  }
 
-#ifndef XSERVER_LIBPCIACCESS
-	  if (cPtr->pEnt->location.type == BUS_PCI)
-	      cPtr->FbBase = xf86MapPciMem(pScrn->scrnIndex,VIDMEM_FRAMEBUFFER,
- 			          cPtr->PciTag, Addr, Map);
-
-	  else
 	      cPtr->FbBase = xf86MapVidMem(pScrn->scrnIndex,VIDMEM_FRAMEBUFFER,
 					   Addr, Map);
-#else
-	  {
-	    void** result = (void**)&cPtr->FbBase;
-	    int err = pci_device_map_range(cPtr->PciInfo,
-					   Addr,
-					   Map,
-					   PCI_DEV_MAP_FLAG_WRITABLE |
-					   PCI_DEV_MAP_FLAG_WRITE_COMBINE,
-					   result);
-	    if (err) 
-	      return FALSE;
-	  }
-
-#endif
 
 	  if (cPtr->FbBase == NULL)
 	      return FALSE;
 	}
 	if (cPtr->Flags & ChipsFullMMIOSupport) {
-#ifndef XSERVER_LIBPCIACCESS
-		cPtr->MMIOBaseVGA = xf86MapPciMem(pScrn->scrnIndex,
-						  VIDMEM_MMIO,cPtr->PciTag,
-						  cPtr->IOAddress, 0x2000L);
-#else
 		cPtr->MMIOBaseVGA = cPtr->MMIOBase;
-#endif
 	    /* 69030 MMIO Fix.
 	     *
 	     * The hardware lets us map the PipeB data registers
@@ -7009,11 +6753,6 @@ chipsMapMem(ScrnInfoPtr pScrn)
 	     * pipe and to toggle between them as necessary. -GHB
 	     */
 	    if (cPtr->Flags & ChipsDualChannelSupport)
-#ifndef XSERVER_LIBPCIACCESS
-	       	cPtr->MMIOBasePipeB = xf86MapPciMem(pScrn->scrnIndex,
-				      VIDMEM_MMIO,cPtr->PciTag,
-				      cPtr->IOAddress + 0x800000, 0x2000L);
-#else
 	    {
 	      void** result = (void**)&cPtr->MMIOBasePipeB;
 	      int err = pci_device_map_range(cPtr->PciInfo,
@@ -7024,7 +6763,6 @@ chipsMapMem(ScrnInfoPtr pScrn)
 	      if (err)
 		return FALSE;
 	    }
-#endif
 
 	    cPtr->MMIOBasePipeA = cPtr->MMIOBaseVGA;
 	}
@@ -7048,39 +6786,21 @@ chipsUnmapMem(ScrnInfoPtr pScrn)
 
     if (cPtr->Flags & ChipsLinearSupport) {
 	if (IS_HiQV(cPtr)) {
-#ifndef XSERVER_LIBPCIACCESS
 	    if (cPtr->MMIOBase)
 		xf86UnMapVidMem(pScrn->scrnIndex, (pointer)cPtr->MMIOBase,
 				0x20000);
 	    if (cPtr->MMIOBasePipeB)
 		xf86UnMapVidMem(pScrn->scrnIndex, (pointer)cPtr->MMIOBasePipeB,
 				0x20000);
-#else
-	    if (cPtr->MMIOBase)
-	      pci_device_unmap_range(cPtr->PciInfo, cPtr->MMIOBase, 0x20000);
-	    
-	    if (cPtr->MMIOBasePipeB)
-	      pci_device_unmap_range(cPtr->PciInfo, cPtr->MMIOBasePipeB, 0x2000);
-	      
-#endif
 	    cPtr->MMIOBasePipeB = NULL;
 	} else {
-#ifndef XSERVER_LIBPCIACCESS
 	  if (cPtr->MMIOBase)
 	      xf86UnMapVidMem(pScrn->scrnIndex, (pointer)cPtr->MMIOBase,
 			      0x10000);
-#else
-	    if (cPtr->MMIOBase)
-	      pci_device_unmap_range(cPtr->PciInfo, cPtr->MMIOBase, 0x10000);
-#endif
 	}
 	cPtr->MMIOBase = NULL;
-#ifndef XSERVER_LIBPCIACCESS
 	xf86UnMapVidMem(pScrn->scrnIndex, (pointer)cPtr->FbBase,
 			cPtr->FbMapSize);
-#else
-	pci_device_unmap_range(cPtr->PciInfo, cPtr->FbBase, cPtr->FbMapSize);
-#endif
     }
     cPtr->FbBase = NULL;
 
